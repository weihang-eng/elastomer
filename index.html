
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hyperelastic Model Fitter</title>

  <!-- Tailwind CSS (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Chart.js v4 (UMD build) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- MathJax for LaTeX -->
  <script>
    window.MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] }, svg: { fontCache: 'global' } };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  <!-- Tailwind theme extension -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#1E3A8A',
            secondary: '#34D399',
            accent: '#F59E0B',
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', 'sans-serif'],
          }
        }
      }
    }
  </script>

  <style>
    /* Keep charts compact and consistent */
    .chart-wrap {
      max-width: 760px;        /* limit width so it doesn't fill the whole page */
    }
    .chart-canvas {
      height: 16rem;           /* fixed height = Tailwind h-64 */
      width: 100%;             /* responsive width within the wrap */
    }
    #dataInputArea {
      min-height: 180px;
      max-height: 360px;
      overflow-y: auto;
      white-space: pre;
      font-family: ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      line-height: 1.25rem;
    }
  </style>
</head>

<body class="bg-gray-50 font-sans text-gray-800 p-4 sm:p-6">
  <div class="max-w-6xl mx-auto">
    <header class="text-center mb-8">
      <h1 class="text-3xl sm:text-4xl font-extrabold text-primary">Hyperelastic Model Fitter</h1>
      <p class="text-sm text-gray-600">Compact, readable plots</p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- Left: Input & Controls -->
      <section class="lg:col-span-1 bg-white p-6 rounded-xl shadow">
        <h2 class="text-xl font-semibold mb-3 text-primary">1. Input Data</h2>
        <p class="text-sm text-gray-600 mb-2">
          Paste pairs (Stretch λ vs. Nominal Stress σ). Delimiters: spaces, tabs, commas, or new lines.
        </p>

        <textarea id="dataInputArea" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-accent focus:border-accent text-sm"
          placeholder="# λ   σ(MPa)
1.05  0.20
1.10  0.45
1.20  0.80
1.50  1.50
2.00  2.50
3.00  4.00
3.50  5.50
4.00  8.00"></textarea>

        <div class="mt-4">
          <h2 class="text-xl font-semibold mb-2 text-primary">2. Model</h2>
          <select id="modelSelector" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-accent focus:border-accent">
            <option value="mooney_rivlin" selected>2‑Term Mooney–Rivlin</option>
            <option value="neo_hookean">Neo‑Hookean</option>
          </select>
        </div>

        <button id="fitButton" class="mt-4 w-full py-2.5 px-4 bg-secondary text-white font-bold rounded-xl hover:bg-emerald-500 transition">
          FIT MATERIAL MODEL
        </button>
      </section>

      <!-- Right: Charts + Results -->
      <section class="lg:col-span-2 space-y-6">
        <!-- Chart area (COMPACT) -->
        <div class="bg-white p-6 rounded-xl shadow">
          <h2 class="text-xl font-semibold mb-3 text-primary">3. Stress–Stretch (compact)</h2>
          <div class="chart-wrap mx-auto">
            <canvas id="stressStrainChart" class="chart-canvas" aria-label="Stress vs Stretch chart"></canvas>
          </div>
        </div>

        <!-- Results -->
        <div class="bg-white p-6 rounded-xl shadow">
          <h2 class="text-xl font-semibold mb-3 text-primary">4. Fitted Parameters</h2>
          <div id="resultsOutput" class="space-y-4">
            <p class="text-gray-500">Press “FIT MATERIAL MODEL” to see results.</p>
          </div>
        </div>
      </section>
    </main>

    <footer class="mt-8 pt-4 border-t border-gray-200 text-center text-xs text-gray-500">
      <p>Mooney–Rivlin uses linear least squares; Neo‑Hookean uses the average of the linearized term. More complex models require non‑linear optimization.</p>
    </footer>
  </div>

  <script>
    // Chart globals
    let stressStrainChart = null;
    const CHART_COLOR_DATA  = '#F59E0B';
    const CHART_COLOR_MODEL = '#1E3A8A';

    // Parse data
    function parseData(dataText) {
      const lines = (dataText || '').trim().split(/\r?\n/);
      const data = [];
      for (const raw of lines) {
        const line = raw.trim();
        if (!line || line.startsWith('#')) continue;
        const parts = line.split(/[\s,;]+/).filter(Boolean);
        if (parts.length < 2) continue;
        const lambda = Number(parts[0]);
        const sigma  = Number(parts[1]);
        if (Number.isFinite(lambda) && Number.isFinite(sigma) && lambda >= 1.0) {
          data.push({ lambda, sigma });
        }
      }
      data.sort((a, b) => a.lambda - b.lambda);
      return data;
    }

    // Models
    function neoHookeanStress(lambda, C1) {
      if (lambda < 1.0) return 0;
      return 2 * C1 * (lambda - Math.pow(lambda, -2));
    }
    function mooneyRivlinStress(lambda, C1, C2) {
      if (lambda < 1.0) return 0;
      return 2 * (lambda - Math.pow(lambda, -2)) * (C1 + C2 * Math.pow(lambda, -1));
    }

    // LLS for 2‑term MR: Y = C1 + C2 X , with Y = σ/[2(λ - λ^-2)], X = λ^-1
    function linearLeastSquares(data) {
      if (!data || data.length < 2) return { C1: 0, C2: 0, R2: 0 };
      const pts = data.map(p => {
        const t = p.lambda - Math.pow(p.lambda, -2);
        const Y = t > 1e-8 ? p.sigma / (2 * t) : 0;
        const X = 1 / p.lambda;
        return { X, Y };
      });

      const n = pts.length;
      let sumX=0,sumY=0,sumXX=0,sumXY=0;
      pts.forEach(p => { sumX+=p.X; sumY+=p.Y; sumXX+=p.X*p.X; sumXY+=p.X*p.Y; });
      const meanX = sumX/n, meanY = sumY/n;

      const num = n*sumXY - sumX*sumY;
      const den = n*sumXX - sumX*sumX;

      let C2 = 0, C1 = meanY;
      if (Math.abs(den) > 1e-12) { C2 = num/den; C1 = meanY - C2*meanX; }

      // R² on linearized space
      let sst=0,sse=0;
      pts.forEach(p => { const yp = C1 + C2*p.X; sst += Math.pow(p.Y-meanY,2); sse += Math.pow(p.Y-yp,2); });
      const R2 = (sst > 1e-12) ? Math.max(0, Math.min(1, 1 - sse/sst)) : 1.0;

      return { C1, C2, R2 };
    }

    function updateChart(experimentalData, modelCurve, stressUnit='Units') {
      const ctx = document.getElementById('stressStrainChart');

      const datasets = [
        { label: 'Experimental', data: experimentalData, borderColor: CHART_COLOR_DATA, backgroundColor: CHART_COLOR_DATA, pointRadius: 3, showLine: false, type: 'scatter' },
        { label: 'Model',        data: modelCurve,      borderColor: CHART_COLOR_MODEL, backgroundColor: 'transparent', borderWidth: 2, pointRadius: 0, tension: 0.25, showLine: true, type: 'line' }
      ];

      const options = {
        responsive: true,
        maintainAspectRatio: true,  // <<< keeps it compact
        aspectRatio: 1.6,           // <<< width/height ratio, matches fixed height above
        interaction: { mode: 'nearest', intersect: false },
        plugins: {
          legend: { position: 'top' },
          title:  { display: true, text: 'Nominal Stress (σ) vs Stretch (λ)', font: { size: 14, weight: 'bold' } },
          tooltip: {
            callbacks: {
              label: (ctx) => {
                const x = ctx.raw?.x ?? ctx.parsed.x;
                const y = ctx.raw?.y ?? ctx.parsed.y;
                return `λ=${x.toFixed(3)}, σ=${y.toFixed(3)} ${stressUnit}`;
              }
            }
          }
        },
        scales: {
          x: { type: 'linear', min: 1.0, title: { display: true, text: 'Stretch, λ', font: { weight: 'bold' } } },
          y: { type: 'linear', title: { display: true, text: `Nominal Stress, σ (${stressUnit})`, font: { weight: 'bold' } }, grace: '5%' }
        }
      };

      if (stressStrainChart) { stressStrainChart.data.datasets = datasets; stressStrainChart.options = options; stressStrainChart.update(); }
      else { stressStrainChart = new Chart(ctx, { data: { datasets }, options }); }
    }

    function displayResults(modelName, params, R2) {
      const outputDiv = document.getElementById('resultsOutput');
      const isMR = modelName === 'mooney_rivlin';
      const modelTitle = isMR ? '2‑Term Mooney–Rivlin' : 'Neo‑Hookean';
      const modelEq   = isMR
        ? '\\(\\sigma = 2(\\lambda - \\lambda^{-2})(C_1 + C_2\\,\\lambda^{-1})\\)'
        : '\\(\\sigma = 2C_1(\\lambda - \\lambda^{-2})\\)';
      const G_small = isMR ? 2*(params.C1 + params.C2) : 2*params.C1;

      outputDiv.innerHTML = `
        <div class="p-3 rounded-xl bg-blue-50 border-l-4 border-primary">
          <h3 class="text-lg font-bold text-primary">${modelTitle}</h3>
          <p class="text-sm text-gray-700">${modelEq}</p>
        </div>
        <div class="p-3 rounded-xl bg-green-50 border-l-4 border-secondary">
          <p class="text-sm font-semibold text-secondary">R²</p>
          <p class="text-xl font-extrabold text-secondary">${R2.toFixed(4)}</p>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
          <div class="p-3 rounded-xl bg-gray-50 border-l-4 border-gray-300">
            <p class="text-xs font-medium text-gray-700">C₁</p>
            <p class="text-lg font-bold text-gray-800">${params.C1.toFixed(6)}</p>
          </div>
          ${isMR ? `
          <div class="p-3 rounded-xl bg-gray-50 border-l-4 border-gray-300">
            <p class="text-xs font-medium text-gray-700">C₂</p>
            <p class="text-lg font-bold text-gray-800">${params.C2.toFixed(6)}</p>
          </div>` : ''}
          <div class="p-3 rounded-xl bg-yellow-50 border-l-4 border-amber-400">
            <p class="text-xs font-medium text-gray-700">Small‑strain G</p>
            <p class="text-lg font-bold text-gray-800">${G_small.toFixed(6)}</p>
          </div>
        </div>
      `;
      if (window.MathJax?.typesetPromise) MathJax.typesetPromise([outputDiv]).catch(()=>{});
    }

    function runFitter() {
      const dataText = document.getElementById('dataInputArea').value;
      const model    = document.getElementById('modelSelector').value;
      const data     = parseData(dataText);

      if (!data || data.length < 2) {
        document.getElementById('resultsOutput').innerHTML =
          '<div class="p-3 rounded-lg bg-red-100 text-red-800 border border-red-200">Error: Provide ≥ 2 valid points (λ ≥ 1).</div>';
        updateChart([], []);
        return;
      }

      let params = { C1: 0, C2: 0 };
      let R2 = 0;
      let stressFn;

      if (model === 'mooney_rivlin') {
        const res = linearLeastSquares(data);
        params = { C1: res.C1, C2: res.C2 };
        R2 = res.R2;
        stressFn = (l) => mooneyRivlinStress(l, params.C1, params.C2);
      } else {
        const Ys = data.map(p => {
          const t = p.lambda - Math.pow(p.lambda, -2);
          return t > 1e-8 ? p.sigma / (2 * t) : 0;
        });
        const C1 = Ys.reduce((s,v)=>s+v,0) / Ys.length;
        params = { C1: C1, C2: 0 };
        stressFn = (l) => neoHookeanStress(l, params.C1);

        const meanSigma = data.reduce((s,p)=>s+p.sigma,0) / data.length;
        let sst=0,sse=0;
        data.forEach(p => { const pred = neoHookeanStress(p.lambda, C1); sst += Math.pow(p.sigma - meanSigma,2); sse += Math.pow(p.sigma - pred,2); });
        R2 = (sst > 1e-12) ? Math.max(0, Math.min(1, 1 - sse/sst)) : 1.0;
      }

      const maxLambda = data[data.length - 1].lambda * 1.05;
      const modelCurve = [];
      for (let l = 1.0; l <= maxLambda + 1e-9; l += 0.05) {
        modelCurve.push({ x: l, y: stressFn(l) });
      }

      const experimental = data.map(p => ({ x: p.lambda, y: p.sigma }));
      updateChart(experimental, modelCurve, 'Units');
      displayResults(model, params, R2);
    }

    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('fitButton').addEventListener('click', runFitter);
      // Run once with whatever is in the box to verify sizing
      runFitter();
    });
  </script>
</body>
</html>
